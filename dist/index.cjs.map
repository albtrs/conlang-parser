{"version":3,"sources":["../src/index.ts","../src/parser.ts"],"sourcesContent":["// Types\n\nexport type { Example, Meaning, Definition, DictionaryEntry } from './types.js';\n\n// Parser\nexport { parseDictionary } from './parser.js';\n","import type { DictionaryEntry, Definition, Meaning, Example } from './types.js';\n\n/**\n * パーサーオプション\n */\n\n\n/**\n * パーサーの内部状態\n */\ninterface ParserState {\n  currentEntry: DictionaryEntry | null;\n  currentDefinition: Definition | null;\n  currentMeaning: Meaning | null;\n}\n\n/**\n * 新しいDictionaryEntryを作成\n */\nfunction createEntry(term: string): DictionaryEntry {\n  return {\n    term,\n    definitions: [],\n  };\n}\n\n/**\n * 新しいDefinition（品詞ブロック）を作成\n */\nfunction createDefinition(pos: string): Definition {\n  return {\n    pos,\n    meanings: [],\n  };\n}\n\n/**\n * 新しいMeaning（訳語・語義）を作成\n */\nfunction createMeaning(gloss: string, tags: Record<string, string[]>): Meaning {\n  return {\n    gloss,\n    tags,\n    examples: [],\n  };\n}\n\n/**\n * 行から埋込タグ [類: match] [対: practice] を抽出\n * @returns { gloss: タグを除いた本文, tags: 抽出したタグ }\n */\nfunction extractTags(line: string): { gloss: string; tags: Record<string, string[]> } {\n  const tags: Record<string, string[]> = {};\n  \n  // [キー: 値] または [キー] のパターンを抽出\n  const tagRegex = /\\[([^\\]:]+)(?::\\s*([^\\]]*))?\\]/g;\n  let match: RegExpExecArray | null;\n  \n  while ((match = tagRegex.exec(line)) !== null) {\n    const key = match[1].trim();\n    const value = match[2]?.trim() || '';\n    \n    if (!tags[key]) {\n      tags[key] = [];\n    }\n    \n    if (value) {\n      // カンマ区切りで複数の値がある場合は分割\n      const values = value.split(',').map(v => v.trim()).filter(v => v.length > 0);\n      tags[key].push(...values);\n    }\n    // 値がない場合（[古]など）は空配列のまま\n  }\n  \n  // タグを除去した本文を返す\n  const gloss = line.replace(tagRegex, '').trim();\n  \n  return { gloss, tags };\n}\n\n/**\n * 例文行をパースして Example オブジェクトを返す\n * @param line \"> \" を除去済みの例文行\n */\nfunction parseExample(line: string): Example {\n  const pipeIndex = line.indexOf('|');\n  if (pipeIndex === -1) {\n    return {\n      original: line.trim(),\n      translation: '',\n    };\n  }\n  return {\n    original: line.slice(0, pipeIndex).trim(),\n    translation: line.slice(pipeIndex + 1).trim(),\n  };\n}\n\n/**\n * 品詞行 <名> から品詞を抽出\n */\nfunction parsePosLine(line: string): string | null {\n  const match = line.match(/^<([^>]+)>$/);\n  return match ? match[1].trim() : null;\n}\n\n/**\n * 現在のMeaningをDefinitionに確定\n */\nfunction finalizeMeaning(state: ParserState): void {\n  if (state.currentMeaning && state.currentDefinition) {\n    state.currentDefinition.meanings.push(state.currentMeaning);\n    state.currentMeaning = null;\n  }\n}\n\n/**\n * 現在のDefinitionをEntryに確定\n */\nfunction finalizeDefinition(state: ParserState): void {\n  finalizeMeaning(state);\n  if (state.currentDefinition && state.currentEntry) {\n    state.currentEntry.definitions.push(state.currentDefinition);\n    state.currentDefinition = null;\n  }\n}\n\n/**\n * 現在のEntryを結果配列に確定\n */\nfunction finalizeEntry(state: ParserState, entries: DictionaryEntry[]): void {\n  finalizeDefinition(state);\n  if (state.currentEntry) {\n    entries.push(state.currentEntry);\n    state.currentEntry = null;\n  }\n}\n\n/**\n * パースエラーを生成\n */\nfunction createParseError(message: string, lineNumber: number, line: string): Error {\n  return new Error(`Parse error at line ${lineNumber}: ${message}\\n  > \"${line}\"`);\n}\n\n/**\n * 行の種類を判定\n */\ntype LineType = 'empty' | 'pos' | 'meaning' | 'example' | 'term';\n\nfunction getLineType(line: string): LineType {\n  if (line === '') {\n    return 'empty';\n  }\n  if (line.startsWith('<') && line.endsWith('>')) {\n    return 'pos';\n  }\n  if (line.startsWith('-')) {\n    return 'meaning';\n  }\n  if (line.startsWith('>')) {\n    return 'example';\n  }\n  return 'term';\n}\n\n/**\n * 辞書テキストをパースしてDictionaryEntry配列を返す\n * @param text パースする辞書テキスト\n * @param options パースオプション\n * @returns パース結果のDictionaryEntry配列\n * @throws パースエラーが発生した場合\n */\nexport function parseDictionary(\n  text: string\n): DictionaryEntry[] {\n  const lines = text.split('\\n');\n  const entries: DictionaryEntry[] = [];\n\n  const state: ParserState = {\n    currentEntry: null,\n    currentDefinition: null,\n    currentMeaning: null,\n  };\n\n\n\n  for (let i = 0; i < lines.length; i++) {\n    const lineNumber = i + 1;\n    const rawLine = lines[i];\n    const line = rawLine.trim();\n\n    const lineType = getLineType(line);\n\n    switch (lineType) {\n      case 'empty':\n        // 空行は無視\n        break;\n\n      case 'pos': {\n        // 品詞行 <名>\n        if (!state.currentEntry) {\n          throw createParseError('POS (<...>) found before term', lineNumber, rawLine);\n        }\n        // 現在のDefinitionを確定\n        finalizeDefinition(state);\n        const pos = parsePosLine(line);\n        if (pos) {\n          state.currentDefinition = createDefinition(pos);\n        }\n        break;\n      }\n\n      case 'meaning': {\n        // 訳語・語義行 - 訳語、説明 [タグ]\n        if (!state.currentEntry) {\n          throw createParseError('Meaning (-) found before term', lineNumber, rawLine);\n        }\n        if (!state.currentDefinition) {\n          throw createParseError('Meaning (-) found before POS (<...>)', lineNumber, rawLine);\n        }\n        // 現在のMeaningを確定\n        finalizeMeaning(state);\n        \n        // - を除去してタグを抽出\n        const content = line.slice(1).trim();\n        const { gloss, tags } = extractTags(content);\n        state.currentMeaning = createMeaning(gloss, tags);\n        break;\n      }\n\n      case 'example': {\n        // 例文行 > 原文 | 訳文\n        if (!state.currentEntry) {\n          throw createParseError('Example (>) found before term', lineNumber, rawLine);\n        }\n        if (!state.currentDefinition) {\n          throw createParseError('Example (>) found before POS (<...>)', lineNumber, rawLine);\n        }\n        if (!state.currentMeaning) {\n          throw createParseError('Example (>) found before meaning (-)', lineNumber, rawLine);\n        }\n        // > を除去して例文をパース\n        const exampleLine = line.slice(1).trim();\n        const example = parseExample(exampleLine);\n        state.currentMeaning.examples.push(example);\n        break;\n      }\n\n      case 'term': {\n        // 見出し語（先頭行 or 新しいエントリ）\n        // 前のエントリを確定\n        finalizeEntry(state, entries);\n        state.currentEntry = createEntry(line);\n        break;\n      }\n    }\n  }\n\n  // 最後のエントリを確定\n  finalizeEntry(state, entries);\n\n  return entries;\n}\n"],"mappings":"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","names":[]}